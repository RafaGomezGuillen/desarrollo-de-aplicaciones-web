1.- Paquetes NuGet:

Identificacion.
- Microsoft.AspNetCore.Authentication.JwtBearer
- Microsoft.AspNetCore.Identity.EntityFrameworkCore
- Microsoft.Extensions.Identity.Core

Modelos, controladores.
- Microsoft.EntityFrameworkCore.InMemory
- Microsoft.EntityFrameworkCore.Sqlite
- Microsoft.EntityFrameworkCore.SqlServe
- Microsoft.EntityFrameworkCore.Tools
- Microsoft.VisualStudio.Web.CodeGeneration.Design

2.- En appsettings.json:

  "JWT": {
    "Issuer": "https://ejercicio3.com",
    "Audience": "GameStoreApp",
    "Key": "ClaveSecretaSupersecreta"
  }

"ConnectionStrings": {
  "UsersDb": "Server=(localdb)\\mssqllocaldb;Database=Users;Trusted_Connection=True;MultipleActiveResultSets=true"
}


3.- En program.cs

 // JWT
 builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
  .AddJwtBearer(options =>
  {
      options.RequireHttpsMetadata = false;
      options.SaveToken = true;
      options.TokenValidationParameters = new TokenValidationParameters
      {
          ValidateIssuer = true,
          ValidateAudience = true,
          ValidateLifetime = true,
          ValidateIssuerSigningKey = true,
          ValidIssuer = builder.Configuration["Jwt:Issuer"],
          ValidAudience = builder.Configuration["Jwt:Audience"],
          IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(builder.Configuration["Jwt:Key"]))
      };
  });

  // Autentificacion en swagger
builder.Services.AddSwaggerGen(c =>
{
    c.SwaggerDoc("v1", new OpenApiInfo { Title = "My API", Version = "v1" });

    // Configuración de seguridad para usar JWT en Swagger
    var securityScheme = new OpenApiSecurityScheme
    {
        Name = "JWT Authentication",
        Description = "Enter JWT Bearer token **_only_**",
        In = ParameterLocation.Header,
        Type = SecuritySchemeType.Http,
        Scheme = "bearer", // must be lower case
        BearerFormat = "JWT",
        Reference = new OpenApiReference
        {
            Id = JwtBearerDefaults.AuthenticationScheme,
            Type = ReferenceType.SecurityScheme
        }
    };

    c.AddSecurityDefinition(securityScheme.Reference.Id, securityScheme);
    c.AddSecurityRequirement(new OpenApiSecurityRequirement
    {
        {securityScheme, new string[] { }}
    });
});

// RequireConfirmedEmail = false
builder.Services.AddIdentityCore<IdentityUser>(options =>
    options.SignIn.RequireConfirmedEmail = false
).AddRoles<IdentityRole>().AddEntityFrameworkStores<UsersContext>();

// Contexto con la base de datos AUTH
builder.Services.AddDbContext<UsersContext>(options =>
{
    options.UseSqlServer(builder.Configuration.GetConnectionString("UsersDb"));
});

arriba de app.UseAuthorization();

app.UseAuthentication();

4.- En la carpeta Data creamos el contexto UsersContext.cs

public class UsersContext:IdentityDbContext<IdentityUser>
{
    public UsersContext (DbContextOptions<UsersContext> options) : base(options)
    {
    }

    protected override void OnModelCreating (ModelBuilder modelBuilder)
    {
        // Seed data
        List<IdentityRole> roles = new()
        {
            new IdentityRole{ Name = "User", NormalizedName = "USER" },
            new IdentityRole{ Name = "Admin", NormalizedName = "ADMIN" },
            new IdentityRole{ Name = "Project manager", NormalizedName = "PROJECT MANAGER" },
        };

        modelBuilder.Entity<IdentityRole>().HasData(roles);

        List<IdentityUser> users = new()
        {
            new () { UserName = "user@ejercicio3.com",  NormalizedUserName = "USER@EJERCICIO3.COM" },
            new () { UserName = "anotheruser@ejercicio3.com",  NormalizedUserName = "ANOTHERUSER@EJERCICIO3.COM" },
            new () { UserName = "thirduser@ejercicio3.com",  NormalizedUserName = "THIRDUSER@EJERCICIO3.COM" },
        };

        modelBuilder.Entity<IdentityUser>().HasData(users);

        var passwordHasher = new PasswordHasher<IdentityUser>();

        foreach (var user in users)
        {
            user.PasswordHash = passwordHasher.HashPassword(user, "Asdf1234!");
        }

        List<IdentityUserRole<string>> userRoles = new()
        {
            new() { UserId = users[0].Id, RoleId = roles[0].Id},
            new() { UserId = users[1].Id, RoleId = roles[1].Id},
            new() { UserId = users[2].Id, RoleId = roles[2].Id},
        };

        modelBuilder.Entity<IdentityUserRole<string>>().HasData(userRoles);
        
        // Importantísimo ANTES de cerrar el corchete del método
        base.OnModelCreating(modelBuilder);
    }
}

Consola NuGet:
- Add-Migration SeedRoles -Context UsersContext
- Update-Database

5.- Creamos el controlador AuthController:

[Route("api/[controller]")]
[ApiController]
public class AuthController:ControllerBase
{
    private readonly UserManager<IdentityUser> _userManager;
    private readonly RoleManager<IdentityRole> _roleManager;
    private readonly IConfiguration _configuration;

    public AuthController (UserManager<IdentityUser> userManager,
                           RoleManager<IdentityRole> roleManager,
                           IConfiguration configuration)
    {
        _userManager = userManager;
        _roleManager = roleManager;
        _configuration = configuration;
    }

    [HttpPost("login")]
    [ProducesResponseType(StatusCodes.Status200OK)]
    [ProducesResponseType(StatusCodes.Status404NotFound)]
    [ProducesResponseType(StatusCodes.Status400BadRequest)]
    public async Task<IActionResult> Login (AuthDTO model)
    {
        // Verifica si el modelo recibido es válido
        if (ModelState.IsValid)
        {
            // Busca al usuario por su nombre (correo electrónico)
            var user = await _userManager.FindByNameAsync(model.Email);

            if (user != null)
            {
                var result = await _userManager.CheckPasswordAsync(user, model.Password);

                // Si la contraseña es correcta
                if (result)
                {
                    // Crea un token JWT y lo devuelve en la respuesta
                    var token = await CreateToken(user);
                    return Ok(new { Token = token });
                }
            }
            else
            {
                return NotFound("Correo no encontrado");
            }
        }

        // El modelo no es válido, devuelve un error de solicitud incorrecta
        return BadRequest("Nombre de usuario/contraseña no válidos");
    }

    [HttpPost("register")]
    [ProducesResponseType(StatusCodes.Status200OK)]
    [ProducesResponseType(StatusCodes.Status404NotFound)]
    [ProducesResponseType(StatusCodes.Status400BadRequest)]
    public async Task<IActionResult> Register ([FromBody] Auth model)
    {
        if (ModelState.IsValid)
        {
            var user = new IdentityUser
            {
                Email = model.Email,
                UserName = model.Email
            };

            // Intenta crear el usuario en la base de datos
            var result = await _userManager.CreateAsync(user, model.Password);

            // Si hay errores en la creación del usuario
            if (!result.Succeeded)
            {
                // Agrega los errores al modelo y devuelve un error de solicitud incorrecta
                foreach (var error in result.Errors)
                {
                    ModelState.AddModelError("", error.Description);
                }
                return BadRequest(ModelState);
            }

            var role = await _roleManager.FindByNameAsync(model.Role);

            // Si el rol no es válido, devuelve un error de solicitud incorrecta
            if (role == null) return BadRequest("El rol no es válido");

            // Asigna el rol al usuario recién creado
            result = await _userManager.AddToRoleAsync(user, role.Name);

            // Si hay errores al asignar el rol, devuelve un error de solicitud incorrecta
            if (!result.Succeeded)
            {
                foreach (var error in result.Errors)
                {
                    ModelState.AddModelError("", error.Description);
                }
                return BadRequest(ModelState);
            }

            var token = await CreateToken(user);

            return Ok(new { Token = token });
        }

        return BadRequest("Nombre de usuario/contraseña no válidos");
    }

    private async Task<string> CreateToken (IdentityUser user)
    {
        var claims = new List<Claim>
         {
             //Identificador único del token
             new(JwtRegisteredClaimNames.Jti, Guid.NewGuid().ToString()),
             //Fecha de emisión del token
             new(JwtRegisteredClaimNames.Iat, DateTime.UtcNow.ToString()),
             //Usuario portador del token
             new(JwtRegisteredClaimNames.Sub, user.UserName)
         };

        var userRoles = await _userManager.GetRolesAsync(user);

        foreach (var userRole in userRoles)
        {
            claims.Add(new Claim("Role", userRole));
        }

        var algo = _configuration["Jwt:Issuer"];
        var key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(_configuration["JWT:Key"]));
        var credentials = new SigningCredentials(key, SecurityAlgorithms.HmacSha256);

        var token = new JwtSecurityToken(
            _configuration["Jwt:Issuer"],
            _configuration["Jwt:Audience"],
            claims,
            expires: DateTime.UtcNow.AddMinutes(20), 
            signingCredentials: credentials
        );

        return new JwtSecurityTokenHandler().WriteToken(token);
    }
}

6.- Autorizacion en los metodos:

[HttpDelete("{id}")]
[ProducesResponseType(StatusCodes.Status200OK)]
[ProducesResponseType(StatusCodes.Status404NotFound)]
[ProducesResponseType(StatusCodes.Status401Unauthorized)]
public async Task<IActionResult> DeleteGame(int id)
{
    // Verifica si el usuario está autenticado
    var user = HttpContext.User;

    if (user == null || !User.Identity.IsAuthenticated)
    {
        return Unauthorized("Error: No estás autorizado para realizar esta acción.");
    }

    // Verifica si hay juegos en la base de datos
    if (_context.Game == null)
    {
        return NotFound($"No hay juegos en la base de datos.");
    }

    // Busca y elimina un juego de la base de datos
    var game = await _context.Game.FindAsync(id);
    
    if (game == null)
    {
        return NotFound($"El juego con id: {id} no ha sido encontrado.");
    }

    _context.Game.Remove(game);
    await _context.SaveChangesAsync();

    return Ok($"El juego con id: {id} ha sido eliminado.");
}




